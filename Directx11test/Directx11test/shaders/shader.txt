#define MAX_LIGHT_NUM 5


struct Light
{
	float3 pos;
	float range;
	float3 dir;
	float cone;
	float3 att;
        int typeofLight;
	float4 ambient;
	float4 diffuse;
};

cbuffer Light : register(b0)
{
    Light light[MAX_LIGHT_NUM];
    int countOfLights;
};

cbuffer WorldMatrixBuffer : register(b0)
{
    float4x4 WVP;
    float4x4 World;
};


Texture2D ObjTexture;
SamplerState ObjSamplerState;
TextureCube SkyMap;

struct VS_OUTPUT
{
    float4 Pos : SV_POSITION;
    float4 worldPos : POSITION;
    float2 TexCoord : TEXCOORD;
    float3 normal : NORMAL;
};

struct SKYMAP_VS_OUTPUT    
{
    float4 Pos : SV_POSITION;
    float3 texCoord : TEXCOORD;
};

VS_OUTPUT VS(float4 inPos : POSITION, float2 inTexCoord : TEXCOORD, float3 normal : NORMAL)
{
    VS_OUTPUT output;

    output.Pos = mul(inPos, WVP);
    output.worldPos = mul(inPos, World);
    output.normal = mul(normal, World);

    output.TexCoord = inTexCoord;

    return output;
}

float4 PS(VS_OUTPUT input) : SV_TARGET
{

input.normal = normalize(input.normal);

	float4 diffuse = ObjTexture.Sample( ObjSamplerState, input.TexCoord );
	float3 finalColor = float3(0.0f, 0.0f, 0.0f);
	float3 finalAmbient = float3(0.0f,0.0f,0.0f);
	
	float3 colors[MAX_LIGHT_NUM];	
	float3 ambients[MAX_LIGHT_NUM];

	
	
for(int i = 0; i < countOfLights; i++)
{
	float3 lightToPixelVec = light[i].pos - input.worldPos;
	float d = length(lightToPixelVec);
	
	if(light[i].typeofLight == 0)
	{
    		colors[i] = float3(0.0f, 0.0f, 0.0f);
		float3 tamb = diffuse * light[i].ambient;
		ambients[i] = tamb;
    		
		if( d > light[i].range )
		{
        	
		colors[i] = ambients[i];
       		continue;

		}
    		lightToPixelVec /= d;  
    	
		float howMuchLight = dot(lightToPixelVec, input.normal);
    		if( howMuchLight > 0.0f )
    		{    
        		colors[i] += diffuse * light[i].diffuse;
        		colors[i] /= (light[i].att[0] + (light[i].att[1] * d)) + (light[i].att[2] * (d*d));        
        		colors[i] *= pow(max(dot(-lightToPixelVec, light[i].dir), 0.0f), light[i].cone);
    		}
    		
		colors[i] = saturate(colors[i] + ambients[i]);
	}	
		else if (light[i].typeofLight == 2)
    		{
    
    		colors[i] = diffuse * light[i].ambient;
    		colors[i] += saturate(dot(light[i].dir, input.normal) * light[i].diffuse * diffuse);
    
		return float4(colors[i], diffuse.a);
    		
		} 
			else if (light[i].typeofLight == 1)
			{
    
    				colors[i] = float3(0.0f, 0.0f, 0.0f);
    				
    				float3 tamb = diffuse * light[i].ambient;
				ambients[i] = tamb;

    				if( d > light[i].range )
				{
        	
				colors[i] = ambients[i];
       				continue;

				}

    				lightToPixelVec /= d; 
    
    				float howMuchLight = dot(lightToPixelVec, input.normal);

    				if( howMuchLight > 0.0f )
    				{    
        				colors[i] += diffuse * light[i].diffuse;
        				colors[i] /= light[i].att[0] + (light[i].att[1] * d) + (light[i].att[2] * (d*d));
    				}    
        
    				colors[i] = saturate(colors[i] + ambients[i]);
    			} 
				else return diffuse;
}

	finalColor = saturate(colors[0] + colors[1] + colors[2] + colors[3] + colors[4]);

	return float4(finalColor, diffuse.a);
}

SKYMAP_VS_OUTPUT SKYMAP_VS(float3 inPos : POSITION, float2 inTexCoord : TEXCOORD, float3 normal : NORMAL)
{
    SKYMAP_VS_OUTPUT output = (SKYMAP_VS_OUTPUT)0;

    output.Pos = mul(float4(inPos, 1.0f), WVP).xyww;

    output.texCoord = inPos;

    return output;
}

float4 SKYMAP_PS(SKYMAP_VS_OUTPUT input) : SV_Target
{
    return SkyMap.Sample(ObjSamplerState, input.texCoord);
}